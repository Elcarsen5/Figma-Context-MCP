import{StdioServerTransport as ae}from"@modelcontextprotocol/sdk/server/stdio.js";import{config as le}from"dotenv";import{resolve as ce}from"path";import{config as K}from"dotenv";import _ from"yargs";import{hideBin as U}from"yargs/helpers";K();function q(e){return e.length<=4?"****":`****${e.slice(-4)}`}function C(e){let t=_(U(process.argv)).options({"figma-api-key":{type:"string",description:"Figma API key"},port:{type:"number",description:"Port to run the server on"}}).help().version("0.1.18").parseSync(),i={figmaApiKey:"",port:3333,configSources:{figmaApiKey:"env",port:"default"}};return t["figma-api-key"]?(i.figmaApiKey=t["figma-api-key"],i.configSources.figmaApiKey="cli"):process.env.FIGMA_API_KEY&&(i.figmaApiKey=process.env.FIGMA_API_KEY,i.configSources.figmaApiKey="env"),t.port?(i.port=t.port,i.configSources.port="cli"):process.env.PORT&&(i.port=parseInt(process.env.PORT,10),i.configSources.port="env"),i.figmaApiKey||(console.error("FIGMA_API_KEY is required (via CLI argument --figma-api-key or .env file)"),process.exit(1)),e||(console.log(`
Configuration:`),console.log(`- FIGMA_API_KEY: ${q(i.figmaApiKey)} (source: ${i.configSources.figmaApiKey})`),console.log(`- PORT: ${i.port} (source: ${i.configSources.port})`),console.log()),i}import{McpServer as re}from"@modelcontextprotocol/sdk/server/mcp.js";import{z as p}from"zod";import S from"fs";import{isTruthy as N}from"remeda";function d(e,t,i){if(!(typeof t=="object"&&t!==null)||!(e in t))return!1;let r=t[e];return i?i(r):r!==void 0}function F(e){return typeof e=="object"&&!!e&&"clipsContent"in e&&typeof e.clipsContent=="boolean"}function P(e){return typeof e=="object"&&!!e&&"absoluteBoundingBox"in e&&typeof e.absoluteBoundingBox=="object"&&!!e.absoluteBoundingBox&&"x"in e.absoluteBoundingBox&&"y"in e.absoluteBoundingBox&&"width"in e.absoluteBoundingBox&&"height"in e.absoluteBoundingBox}function k(e){return typeof e=="object"&&e!==null&&"top"in e&&"right"in e&&"bottom"in e&&"left"in e}function A(e,t){let i=t;return typeof t=="object"&&!!t&&e in i&&typeof i[e]=="object"&&!!i[e]&&"x"in i[e]&&"y"in i[e]&&"width"in i[e]&&"height"in i[e]}function D(e){return Array.isArray(e)&&e.length===4&&e.every(t=>typeof t=="number")}import m from"fs";import X from"path";async function E(e,t,i){try{m.existsSync(t)||m.mkdirSync(t,{recursive:!0});let o=X.join(t,e),r=await fetch(i,{method:"GET"});if(!r.ok)throw new Error(`Failed to download image: ${r.statusText}`);let n=m.createWriteStream(o),a=r.body?.getReader();if(!a)throw new Error("Failed to get response body");return new Promise((c,l)=>{let u=async()=>{try{for(;;){let{done:s,value:f}=await a.read();if(s){n.end();break}n.write(f)}c(o)}catch(s){n.end(),m.unlink(o,()=>{}),l(s)}};n.on("error",s=>{a.cancel(),m.unlink(o,()=>{}),l(new Error(`Failed to write image: ${s.message}`))}),u()})}catch(o){let r=o instanceof Error?o.message:String(o);throw new Error(`Error downloading image: ${r}`)}}function b(e){if(typeof e!="object"||e===null)return e;if(Array.isArray(e))return e.map(i=>b(i));let t={};for(let i in e)if(Object.prototype.hasOwnProperty.call(e,i)){let o=e[i],r=b(o);r!==void 0&&!(Array.isArray(r)&&r.length===0)&&!(typeof r=="object"&&r!==null&&Object.keys(r).length===0)&&(t[i]=r)}return t}function G(e,t=1){let i=Math.round(e.r*255),o=Math.round(e.g*255),r=Math.round(e.b*255),n=Math.round(t*e.a*100)/100;return{hex:"#"+((1<<24)+(i<<16)+(o<<8)+r).toString(16).slice(1).toUpperCase(),opacity:n}}function x(e,t=1){let i=Math.round(e.r*255),o=Math.round(e.g*255),r=Math.round(e.b*255),n=Math.round(t*e.a*100)/100;return`rgba(${i}, ${o}, ${r}, ${n})`}function H(e="var"){let t="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",i="";for(let o=0;o<6;o++){let r=Math.floor(Math.random()*t.length);i+=t[r]}return`${e}_${i}`}function w(e,{ignoreZero:t=!0,suffix:i="px"}={}){let{top:o,right:r,bottom:n,left:a}=e;if(!(t&&o===0&&r===0&&n===0&&a===0))return o===r&&r===n&&n===a?`${o}${i}`:r===a?o===n?`${o}${i} ${r}${i}`:`${o}${i} ${r}${i} ${n}${i}`:`${o}${i} ${r}${i} ${n}${i} ${a}${i}`}function v(e){if(e.type==="IMAGE")return{type:"IMAGE",imageRef:e.imageRef,scaleMode:e.scaleMode};if(e.type==="SOLID"){let{hex:t,opacity:i}=G(e.color,e.opacity);return i===1?t:x(e.color,i)}else{if(["GRADIENT_LINEAR","GRADIENT_RADIAL","GRADIENT_ANGULAR","GRADIENT_DIAMOND"].includes(e.type))return{type:e.type,gradientHandlePositions:e.gradientHandlePositions,gradientStops:e.gradientStops.map(({position:t,color:i})=>({position:t,color:G(i)}))};throw new Error(`Unknown paint type: ${e.type}`)}}function h(e){return e.visible??!0}function V(e,t){let i=Z(e),o=Q(e,t,i.mode)||{};return{...i,...o}}function L(e,t){if(t&&t.mode!=="none"){let{children:i,mode:o,axis:r}=t,n=J(r,o);if(i.length>0&&i.reduce((c,l)=>c?"layoutPositioning"in l&&l.layoutPositioning==="ABSOLUTE"?!0:n==="horizontal"?"layoutSizingHorizontal"in l&&l.layoutSizingHorizontal==="FILL":n==="vertical"?"layoutSizingVertical"in l&&l.layoutSizingVertical==="FILL":!1:!1,!0))return"stretch"}switch(e){case"MIN":return;case"MAX":return"flex-end";case"CENTER":return"center";case"SPACE_BETWEEN":return"space-between";case"BASELINE":return"baseline";default:return}}function Y(e){switch(e){case"MIN":return;case"MAX":return"flex-end";case"CENTER":return"center";case"STRETCH":return"stretch";default:return}}function M(e){if(e==="FIXED")return"fixed";if(e==="FILL")return"fill";if(e==="HUG")return"hug"}function J(e,t){switch(e){case"primary":switch(t){case"row":return"horizontal";case"column":return"vertical"}case"counter":switch(t){case"row":return"horizontal";case"column":return"vertical"}}}function Z(e){if(!F(e))return{mode:"none"};let t={mode:!e.layoutMode||e.layoutMode==="NONE"?"none":e.layoutMode==="HORIZONTAL"?"row":"column"},i=[];return e.overflowDirection?.includes("HORIZONTAL")&&i.push("x"),e.overflowDirection?.includes("VERTICAL")&&i.push("y"),i.length>0&&(t.overflowScroll=i),t.mode==="none"||(t.justifyContent=L(e.primaryAxisAlignItems??"MIN",{children:e.children,axis:"primary",mode:t.mode}),t.alignItems=L(e.counterAxisAlignItems??"MIN",{children:e.children,axis:"counter",mode:t.mode}),t.alignSelf=Y(e.layoutAlign),t.wrap=e.layoutWrap==="WRAP"?!0:void 0,t.gap=e.itemSpacing?`${e.itemSpacing??0}px`:void 0,(e.paddingTop||e.paddingBottom||e.paddingLeft||e.paddingRight)&&(t.padding=w({top:e.paddingTop??0,right:e.paddingRight??0,bottom:e.paddingBottom??0,left:e.paddingLeft??0}))),t}function Q(e,t,i){if(!P(e))return;let o={mode:i};if(o.sizing={horizontal:M(e.layoutSizingHorizontal),vertical:M(e.layoutSizingVertical)},F(t)&&(t?.layoutMode==="NONE"||e.layoutPositioning==="ABSOLUTE"))return e.layoutPositioning==="ABSOLUTE"&&(o.position="absolute"),e.absoluteBoundingBox&&t.absoluteBoundingBox&&(o.locationRelativeToParent={x:e.absoluteBoundingBox.x-(t?.absoluteBoundingBox?.x??e.absoluteBoundingBox.x),y:e.absoluteBoundingBox.y-(t?.absoluteBoundingBox?.y??e.absoluteBoundingBox.y)}),o;if(A("absoluteBoundingBox",e)&&A("absoluteBoundingBox",t)){let r={};i==="row"?(!e.layoutGrow&&e.layoutSizingHorizontal=="FIXED"&&(r.width=e.absoluteBoundingBox.width),e.layoutAlign!=="STRETCH"&&e.layoutSizingVertical=="FIXED"&&(r.height=e.absoluteBoundingBox.height)):i==="column"&&(e.layoutAlign!=="STRETCH"&&e.layoutSizingHorizontal=="FIXED"&&(r.width=e.absoluteBoundingBox.width),!e.layoutGrow&&e.layoutSizingVertical=="FIXED"&&(r.height=e.absoluteBoundingBox.height),e.preserveRatio&&(r.aspectRatio=e.absoluteBoundingBox?.width/e.absoluteBoundingBox?.height)),Object.keys(r).length>0&&(o.dimensions=r)}return o}function O(e){let t={colors:[]};return d("strokes",e)&&Array.isArray(e.strokes)&&e.strokes.length&&(t.colors=e.strokes.filter(h).map(v)),d("strokeWeight",e)&&typeof e.strokeWeight=="number"&&e.strokeWeight>0&&(t.strokeWeight=`${e.strokeWeight}px`),d("strokeDashes",e)&&Array.isArray(e.strokeDashes)&&e.strokeDashes.length&&(t.strokeDashes=e.strokeDashes),d("individualStrokeWeights",e,k)&&(t.strokeWeight=w(e.individualStrokeWeights)),t}function j(e){if(!d("effects",e))return{};let t=e.effects.filter(l=>l.visible),i=t.filter(l=>l.type==="DROP_SHADOW").map(ee),o=t.filter(l=>l.type==="INNER_SHADOW").map(te),r=[...i,...o].join(", "),n=t.filter(l=>l.type==="LAYER_BLUR").map(z).join(" "),a=t.filter(l=>l.type==="BACKGROUND_BLUR").map(z).join(" "),c={};return r&&(c.boxShadow=r),n&&(c.filter=n),a&&(c.backdropFilter=a),c}function ee(e){return`${e.offset.x}px ${e.offset.y}px ${e.radius}px ${e.spread??0}px ${x(e.color)}`}function te(e){return`inset ${e.offset.x}px ${e.offset.y}px ${e.radius}px ${e.spread??0}px ${x(e.color)}`}function z(e){return`blur(${e.radius}px)`}function T(e){let{name:t,lastModified:i,thumbnailUrl:o}=e,r;"document"in e?r=Object.values(e.document.children):r=Object.values(e.nodes).map(c=>c.document);let n={styles:{}},a=r.filter(h).map(c=>W(n,c)).filter(c=>c!=null);return{name:t,lastModified:i,thumbnailUrl:o||"",nodes:a,globalVars:n}}function y(e,t,i){let[o]=Object.entries(e.styles).find(([n,a])=>JSON.stringify(a)===JSON.stringify(t))??[];if(o)return o;let r=H(i);return e.styles[r]=t,r}function W(e,t,i){let{id:o,name:r,type:n}=t,a={id:o,name:r,type:n};if(d("style",t)&&Object.keys(t.style).length){let s=t.style,f={fontFamily:s.fontFamily,fontWeight:s.fontWeight,fontSize:s.fontSize,lineHeight:s.lineHeightPx&&s.fontSize?`${s.lineHeightPx/s.fontSize}em`:void 0,letterSpacing:s.letterSpacing&&s.letterSpacing!==0&&s.fontSize?`${s.letterSpacing/s.fontSize*100}%`:void 0,textCase:s.textCase,textAlignHorizontal:s.textAlignHorizontal,textAlignVertical:s.textAlignVertical};a.textStyle=y(e,f,"style")}if(d("fills",t)&&Array.isArray(t.fills)&&t.fills.length){let s=t.fills.map(v);a.fills=y(e,s,"fill")}let c=O(t);c.colors.length&&(a.strokes=y(e,c,"stroke"));let l=j(t);Object.keys(l).length&&(a.effects=y(e,l,"effect"));let u=V(t,i);if(Object.keys(u).length>1&&(a.layout=y(e,u,"layout")),d("characters",t,N)&&(a.text=t.characters),d("opacity",t)&&typeof t.opacity=="number"&&t.opacity!==1&&(a.opacity=t.opacity),d("cornerRadius",t)&&typeof t.cornerRadius=="number"&&(a.borderRadius=`${t.cornerRadius}px`),d("rectangleCornerRadii",t,D)&&(a.borderRadius=`${t.rectangleCornerRadii[0]}px ${t.rectangleCornerRadii[1]}px ${t.rectangleCornerRadii[2]}px ${t.rectangleCornerRadii[3]}px`),d("children",t)&&t.children.length>0){let s=t.children.filter(h).map(f=>W(e,f,t)).filter(f=>f!=null);s.length&&(a.children=s)}return n==="VECTOR"&&(a.type="IMAGE-SVG"),b(a)}import ie from"js-yaml";var I=class{constructor(t){this.baseUrl="https://api.figma.com/v1";this.apiKey=t}async request(t){if(typeof fetch!="function")throw new Error("The MCP server is being run in a Node.js environment where `fetch` is not available. You won't be able to access any data related to the Figma file.\n\nAs the coding AI assistant, PLEASE ABORT THE CURRENT REQUEST. No alternate approaches will work. Help the user fix this issue so you can proceed by letting them know that they need to run the MCP server with Node.js version 18 or higher.");try{g.log(`Calling ${this.baseUrl}${t}`);let i=await fetch(`${this.baseUrl}${t}`,{headers:{"X-Figma-Token":this.apiKey}});if(!i.ok)throw{status:i.status,err:i.statusText||"Unknown error"};return await i.json()}catch(i){throw i.status?i:i instanceof Error?new Error(`Failed to make request to Figma API: ${i.message}`):new Error(`Failed to make request to Figma API: ${i}`)}}async getImageFills(t,i,o){if(i.length===0)return[];let r=[],n=`/files/${t}/images`,a=await this.request(n),{images:c={}}=a.meta;return r=i.map(async({imageRef:l,fileName:u})=>{let s=c[l];return s?E(u,o,s):""}),Promise.all(r)}async getImages(t,i,o){let r=i.filter(({fileType:s})=>s==="png").map(({nodeId:s})=>s),n=r.length>0?this.request(`/images/${t}?ids=${r.join(",")}&scale=2&format=png`).then(({images:s={}})=>s):{},a=i.filter(({fileType:s})=>s==="svg").map(({nodeId:s})=>s),c=a.length>0?this.request(`/images/${t}?ids=${a.join(",")}&format=svg`).then(({images:s={}})=>s):{},l=await Promise.all([n,c]).then(([s,f])=>({...s,...f})),u=i.map(({nodeId:s,fileName:f})=>{let B=l[s];return B?E(f,o,B):!1}).filter(s=>!!s);return Promise.all(u)}async getFile(t,i){try{let o=`/files/${t}${i?`?depth=${i}`:""}`;g.log(`Retrieving Figma file: ${t} (depth: ${i??"default"})`);let r=await this.request(o);g.log("Got response");let n=T(r);return R("figma-raw.yml",r),R("figma-simplified.yml",n),n}catch(o){throw console.error("Failed to get file:",o),o}}async getNode(t,i,o){let r=`/files/${t}/nodes?ids=${i}${o?`&depth=${o}`:""}`,n=await this.request(r);g.log("Got response from getNode, now parsing."),R("figma-raw.yml",n);let a=T(n);return R("figma-simplified.yml",a),a}};function R(e,t){try{if(process.env.NODE_ENV!=="development")return;let i="logs";try{S.accessSync(process.cwd(),S.constants.W_OK)}catch(o){g.log("Failed to write logs:",o);return}S.existsSync(i)||S.mkdirSync(i),S.writeFileSync(`${i}/${e}`,ie.dump(t))}catch(i){console.debug("Failed to write logs:",i)}}import oe from"express";import{SSEServerTransport as ne}from"@modelcontextprotocol/sdk/server/sse.js";import se from"js-yaml";var g={log:(...e)=>{},error:(...e)=>{}},$=class{constructor(t){this.transports={};this.httpServer=null;this.figmaService=new I(t),this.server=new re({name:"Figma MCP Server",version:"0.1.18"},{capabilities:{logging:{},tools:{}}}),this.registerTools()}registerTools(){this.server.tool("get_figma_data","When the nodeId cannot be obtained, obtain the layout information about the entire Figma file",{fileKey:p.string().describe("The key of the Figma file to fetch, often found in a provided URL like figma.com/(file|design)/<fileKey>/..."),nodeId:p.string().optional().describe("The ID of the node to fetch, often found as URL parameter node-id=<nodeId>, always use if provided"),depth:p.number().optional().describe("How many levels deep to traverse the node tree, only use if explicitly requested by the user")},async({fileKey:t,nodeId:i,depth:o})=>{try{g.log(`Fetching ${o?`${o} layers deep`:"all layers"} of ${i?`node ${i} from file`:"full file"} ${t}`);let r;i?r=await this.figmaService.getNode(t,i,o):r=await this.figmaService.getFile(t,o),g.log(`Successfully fetched file: ${r.name}`);let{nodes:n,globalVars:a,...c}=r,l={metadata:c,nodes:n,globalVars:a};g.log("Generating YAML result from file");let u=se.dump(l);return g.log("Sending result to client"),{content:[{type:"text",text:u}]}}catch(r){let n=r instanceof Error?r.message:JSON.stringify(r);return g.error(`Error fetching file ${t}:`,n),{isError:!0,content:[{type:"text",text:`Error fetching file: ${n}`}]}}}),this.server.tool("download_figma_images","Download SVG and PNG images used in a Figma file based on the IDs of image or icon nodes",{fileKey:p.string().describe("The key of the Figma file containing the node"),nodes:p.object({nodeId:p.string().describe("The ID of the Figma image node to fetch, formatted as 1234:5678"),imageRef:p.string().optional().describe("If a node has an imageRef fill, you must include this variable. Leave blank when downloading Vector SVG images."),fileName:p.string().describe("The local name for saving the fetched file")}).array().describe("The nodes to fetch as images"),localPath:p.string().describe("The absolute path to the directory where images are stored in the project. If the directory does not exist, it will be created. The format of this path should respect the directory format of the operating system you are running on. Don't use any special character escaping in the path name either.")},async({fileKey:t,nodes:i,localPath:o})=>{try{let r=i.filter(({imageRef:s})=>!!s),n=this.figmaService.getImageFills(t,r,o),a=i.filter(({imageRef:s})=>!s).map(({nodeId:s,fileName:f})=>({nodeId:s,fileName:f,fileType:f.endsWith(".svg")?"svg":"png"})),c=this.figmaService.getImages(t,a,o),l=await Promise.all([n,c]).then(([s,f])=>[...s,...f]);return{content:[{type:"text",text:!l.find(s=>!s)?`Success, ${l.length} images downloaded: ${l.join(", ")}`:"Failed"}]}}catch(r){return g.error(`Error downloading images from file ${t}:`,r),{isError:!0,content:[{type:"text",text:`Error downloading images: ${r}`}]}}})}async connect(t){await this.server.connect(t),g.log=(...o)=>{console.error("[INFO]",...o)},g.error=(...o)=>{console.error("[ERROR]",...o)};let i=process.stdout.write.bind(process.stdout);process.stdout.write=(o,r,n)=>typeof o=="string"&&!o.startsWith("{")?!0:i(o,r,n),g.log("Server connected and ready to process requests")}async startHttpServer(t){let i=oe();i.get("/sse",async(o,r)=>{console.log("Establishing new SSE connection");let n=new ne("/messages",r);console.log(`New SSE connection established for sessionId ${n.sessionId}`),this.transports[n.sessionId]=n,r.on("close",()=>{delete this.transports[n.sessionId]}),await this.server.connect(n)}),i.post("/messages",async(o,r)=>{let n=o.query.sessionId;if(!this.transports[n]){r.status(400).send(`No transport found for sessionId ${n}`);return}console.log(`Received message for sessionId ${n}`),await this.transports[n].handlePostMessage(o,r)}),g.log=console.log,g.error=console.error,this.httpServer=i.listen(t,()=>{g.log(`HTTP server listening on port ${t}`),g.log(`SSE endpoint available at http://localhost:${t}/sse`),g.log(`Message endpoint available at http://localhost:${t}/messages`)})}async stopHttpServer(){if(!this.httpServer)throw new Error("HTTP server is not running");return new Promise((t,i)=>{this.httpServer.close(o=>{if(o){i(o);return}this.httpServer=null;let r=Object.values(this.transports).map(n=>n.close());Promise.all(r).then(()=>{t()})})})}};le({path:ce(process.cwd(),".env")});async function ge(){let e=process.env.NODE_ENV==="cli"||process.argv.includes("--stdio"),t=C(e),i=new $(t.figmaApiKey);if(e){let o=new ae;await i.connect(o)}else console.log(`Initializing Figma MCP Server in HTTP mode on port ${t.port}...`),await i.startHttpServer(t.port)}process.argv[1]&&ge().catch(e=>{console.error("Failed to start server:",e),process.exit(1)});export{$ as a,C as b,ge as c};
